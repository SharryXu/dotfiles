#!/usr/bin/env bash -l

# TODO: 1.Add parameter to deal Depth

# Sync git repository.
# Globals:
#   print
#   git
#   is-git-repo
#   current-git-branch
# Arguments:
#   Folder Path
#   Remote Repository Name
#   Remote Repository Path
#   Branch Name (Optional)
#   Depth (Optional)
# Returns:
#   None

function usage() {
  echo -e "\nusage: $(basename $0) [options] local_folder_path

[options]:
-r  remote repository path
    For example: https://github.com/SharryXu/dotfiles
-b  branch. Default value is master.
-s  source name. Default value is origin.
-t  target name. Default value is origin.
-f  directly push unstaged changes.
-h  help information.

Warning: For now, we assume the branch name in source and target are the same."
  exit 1
}

branch="master"
source_name="origin"
target_name="origin"
local_repo_path=""
remote_repo_path=""
directly_push=$false

while getopts "r:b:s:t:hf" option; do
  case $option in
    r) remote_repo_path=${OPTARG}
       if [[ "$remote_repo_path" != "git@"* && "$remote_repo_path" != "https"* ]]; then
         print 3 "The remote repository path has invalid format."
         exit 1
       fi
       ;;
    b) if [[ -z "${OPTARG}" ]]; then
         print 3 "The branch name cannot be empty or whitespaces."
         exit 1
       fi
       branch=${OPTARG}
       ;;
    s) if [[ -z "${OPTARG}" ]]; then
         print 3 "The source ref name cannot be empty or whitespaces."
         exit 1
       fi
       source_name=${OPTARG}
       ;;
    t) if [[ -z "${OPTARG}" ]]; then
         print 3 "The target ref name cannot be empty or whitespaces."
         exit 1
       fi
       target_name=${OPTARG}
       ;;
    f) directly_push=$true
       ;;
    h) usage
       ;;
  esac
done

shift $((OPTIND-1))

if [[ $# == 1 && ! -z $1 ]]; then
  local_repo_path=$(realpath "$1")
  if is-git-repo "$local_repo_path"; then
    print 1 "Redirect to $local_repo_path" && cd "$local_repo_path"
    current_remote_repo_path=$(git ls-remote --get-url)
    # Sometimes, the URL ends with '.git'.
    if [[ -z $remote_repo_path || "$current_remote_repo_path" == "$remote_repo_path"* ]]; then
      print 0 "Repository has already existed."
      current_branch=$(current-git-branch)

      # TODO: Make this a new command.
      # ===================================================
      if [[ -z "$(git status --porcelain)" ]]; then
        print 0 "Current repository is clean."
      else
        if [[ $(choose-yes-or-no "Do you want to commit those changes?") == $true ]]; then
          print 0 "Please provide appropriate message:"
          read commitMessage
          if [[ -z $commitMessage ]]; then
            commitMessage="Save latest changes."
          fi

          git add . && git commit -m "$commitMessage"

          if [[ $directly_push == $true || $(choose-yes-or-no "Do you want to push thos changes?") == $true ]]; then
            git push -u $target_name $branch && git push
            if [[ $? == $true ]]; then
              print 1 "Push changes success."
            else
              print 3 "Push changes failed."
              exit 1
            fi
          fi
        else
          print 0 "There are uncommited files."
          exit 0
        fi
      fi
      # ===================================================

      # TODO: git pull --all
      for file in "$local_repo_path"/.git/refs/heads/*; do
        current_head=${file##*/}
        print 0 "Pulling latest code for $current_head branch..."
        git checkout $current_head && git pull "$target_name" "$current_head"
      done

      if [[ "$source_name" != "$target_name" ]]; then
        # git checkout "$source_name/$branch"
        print 0 "Fetch latest code from $source_name/$branch..."
        git fetch "$source_name" "$branch"
        print 0 "Merge the code from $source_name/$branch to $target_name/$branch..."
        git merge "$target_name/$branch"
      fi

      if [[ $current_branch != "unamed" ]]; then
        print 0 "Checkout to the original branch..."
        git checkout $current_branch
      fi
    else
      print 3 "The current address is $current_remote_repo_path which is not match with the one you provide $remote_repo_path."
      exit 1
    fi
    print 1 "Redirect to original folder" && cd - 1>/dev/null 2>&1
  elif [[ -d $local_repo_path && $(is-folder-empty "$local_repo_path") == $true ]]; then
    print 3 "The folder is not a git repository and it's not empty."
    exit 1
  elif [[ ! -z $remote_repo_path ]]; then
    git clone "$remote_repo_path" "$local_repo_path"
  else
    print 3 "Please provide valid local or remote git repository."
    exit 1
  fi
else
  print 3 "Please provide local folder."
  usage
fi
